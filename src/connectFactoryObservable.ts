import { Observable } from "rxjs"
import shareLatest from "./internal/share-latest"
import reactEnhancer from "./internal/react-enhancer"
import { BehaviorObservable } from "./internal/BehaviorObservable"
import { useObservable } from "./internal/useObservable"
import { SUSPENSE } from "./SUSPENSE"
import { takeUntilComplete } from "./internal/take-until-complete"

interface ConnectFactoryObservable {
  <A extends (number | string | boolean | null)[], O>(
    getObservable: (...args: A) => Observable<O>,
    unsubscribeGraceTime?: number,
  ): readonly [
    (...args: A) => Exclude<O, typeof SUSPENSE>,
    (...args: A) => Observable<O>,
  ]
  <A extends Object, O>(
    getObservable: (key: A) => Observable<O>,
    unsubscribeGraceTime?: number,
  ): readonly [
    (key: A) => Exclude<O, typeof SUSPENSE>,
    (key: A) => Observable<O>,
  ]
}

/**
 * Accepts: A factory function that returns an Observable.
 *
 * Returns [1, 2]
 * 1. A React Hook function with the same parameters as the factory function.
 *  This hook will yield the latest update from the observable returned from
 *  the factory function.
 * 2. A `sharedLatest` version of the observable generated by the factory
 *  function that can be used for composing other streams that depend on it.
 *  The shared subscription is closed as soon as there are no subscribers to
 *  that observable.
 *
 * @param getObservable Factory of observables. The arguments of this function
 *  will be the ones used in the hook.
 * @param unsubscribeGraceTime (= 200): Amount of time in ms that the shared
 *  observable should wait before unsubscribing from the source observable when
 *  there are no new subscribers.
 *
 * @remarks If the Observable doesn't synchronously emit a value upon the first
 * subscription, then the hook will leverage React Suspense while it's waiting
 * for the first value.
 */
export const connectFactoryObservable: ConnectFactoryObservable = <O>(
  getObservable: (...args: any) => Observable<O>,
  unsubscribeGraceTime = 200,
) => {
  const cache = new Map<
    string | Object,
    [Observable<O>, BehaviorObservable<O>]
  >()

  const getSharedObservables$ = (
    ...input: any
  ): [Observable<O>, BehaviorObservable<O>] => {
    const key =
      input.length === 1 && typeof input[0] === "object" && input[0] !== null
        ? input[0]
        : JSON.stringify(input)
    const cachedVal = cache.get(key)

    if (cachedVal) {
      return cachedVal
    }

    const sharedObservable$ = shareLatest(getObservable(...input), () => {
      cache.delete(key)
    })

    const reactObservable$ = reactEnhancer(
      sharedObservable$,
      unsubscribeGraceTime,
    )

    const result: [Observable<O>, BehaviorObservable<O>] = [
      takeUntilComplete(sharedObservable$),
      reactObservable$,
    ]

    cache.set(key, result)
    return result
  }

  return [
    (...input: any) => useObservable(getSharedObservables$(...input)[1]),
    (...input: any) => getSharedObservables$(...input)[0],
  ] as const
}
